# Лабораторная работа №1. Разработка пользовательского интерфейса (GUI) для языкового процессора.
## Цель работы: Разработать приложение – текстовый редактор. 

## Установка

### На Linux

#### Установка зависимостей:
```sh
sudo dnf install qt5-qtbase-devel qt5-qmake
```

#### Скачивание проекта:
```sh
git clone https://github.com/Rokli/Complier.git
cd Complier
```

#### Сборка проекта:
```sh
qmake
make
```

#### Запуск:
```sh
./complier
```

### На Windows

#### Установка Qt:
[Скачать и установить Qt](https://doc.qt.io/qt-6/windows.html)

#### Скачивание проекта:
```sh
git clone https://github.com/Rokli/Complier.git
cd Complier
```

#### Сборка проекта:
```sh
cd C:\path\to\Complier
qmake
mingw32-make
```

#### Запуск:
```sh
complier.exe
```

## Как пользоваться компилятором

### Файл (работа с файлами .txt)
- **Создать** — создаёт новый файл
- **Открыть** — открывает существующий файл
- **Сохранить** — сохраняет изменения в текущем файле
- **Сохранить как** — сохраняет текущий файл в указанное место
- **Выход** — закрывает приложение

### Правка (редактирование текста)
- **Отменить** — отменяет последнее изменение
- **Повторить** — повторяет последнюю операцию
- **Вырезать** — вырезает выделенный текст
- **Копировать** — копирует выделенный текст
- **Вставить** — вставляет текст из буфера обмена
- **Удалить** — удаляет выделенный текст
- **Выделить всё** — выделяет весь текст

### Справка
- **Вызов справки** — открывает документацию в браузере
- **О программе** — отображает дополнительное окно с информацией о программе


# Лабораторная работа №3. Разработка синтаксического анализатора (парсера)
## Цель работы: Изучить назначение синтаксического анализатора. Спроектировать алгоритм и выполнить программную реализацию парсера.
## Персональный вариант:
Компилятор ассоциативного массива `map <string,int> dsa;` языка C++.\
## Грамматика:"
<MAP> -> 'map' <OB> 
<OB> -> '<' <KEYTYPE> 
<KEYTYPE> -> type <COMM> 
<COMM> -> ',' <VALUETYPE>  
<VALUETYPE > -> type <CB> 
<CB> -> '>' <VARREM> 
< VARREM > -> letter <VARREM> 
< VARREM > -> ';' 
<letter> → "a" | "b" | "c" | ... | "z" | "A" | "B" | "C" | ... | "Z" | 
<type> → "int" | "string" | "double" | "float" | 
## Граф:
![img](https://github.com/user-attachments/assets/aaa6cff0-5ab4-44b9-ba63-1ad8291194c9)

### Тестовые примеры:
![Вставленное изображение](https://github.com/user-attachments/assets/7494bc8d-f214-41e3-a780-662ac158791e)
![image](https://github.com/user-attachments/assets/674aece2-d825-46a5-bec7-c62ff59da252)
![image](https://github.com/user-attachments/assets/7bb44430-cf85-4bf7-902b-db2d8d38b1aa)
![image](https://github.com/user-attachments/assets/ebdc767e-da74-410a-8816-8e9c614316e6)


# Лабораторная работа №4. Разработка синтаксического анализатора (парсера)
## Цель работы: Изучить назначение синтаксического анализатора. Спроектировать алгоритм и выполнить программную реализацию парсера.
## Персональный вариант:
Компилятор ассоциативного массива `map <string,int> dsa;` языка C++.\
## Грамматика:"
<MAP> -> 'map' <OB> 
<OB> -> '<' <KEYTYPE> 
<KEYTYPE> -> type <COMM> 
<COMM> -> ',' <VALUETYPE>  
<VALUETYPE > -> type <CB> 
<CB> -> '>' <VARREM> 
< VARREM > -> letter <VARREM> 
< VARREM > -> ';' 
<letter> → "a" | "b" | "c" | ... | "z" | "A" | "B" | "C" | ... | "Z" | 
<type> → "int" | "string" | "double" | "float" | 
## Граф:
![img](https://github.com/user-attachments/assets/aaa6cff0-5ab4-44b9-ba63-1ad8291194c9)

### Тестовые примеры:
![Вставленное изображение](https://github.com/user-attachments/assets/7494bc8d-f214-41e3-a780-662ac158791e)
![image](https://github.com/user-attachments/assets/674aece2-d825-46a5-bec7-c62ff59da252)
![image](https://github.com/user-attachments/assets/7bb44430-cf85-4bf7-902b-db2d8d38b1aa)
![image](https://github.com/user-attachments/assets/ebdc767e-da74-410a-8816-8e9c614316e6)



# Лабораторная работа №5. Включение семантики в анализатор. Создание внутренней формы представления программы.
## Цель работы: Дополнить анализатор, разработанный в рамках лабораторных работ, этапом формирования внутренней формы представления программы.
## Персональный вариант:
1 вариант. В качестве внутренней формы представления программы выберем польскую инверсную запись (ПОЛИЗ). Эта форма представления наглядна и достаточно проста для последующей интерпретации, которая может быть выполнена с использованием стека.

Задание:

1) Реализовать в текстовом редакторе поиск лексических и синтаксических ошибок для грамматики G[<E>]. Реализовать данную КС-граммматику методом рекурсивного спуска:

1. E → TA 

2. A → ε | + TA | - TA 

3. T → ОВ 

4. В → ε | *ОВ | /ОВ 

5. О → num | (E) 

6. num  → digit {digit}

2) Реализовать алгоритм записи арифметических выражений в ПОЛИЗ и алгоритм вычисления выражений в ПОЛИЗ.

### Примеры допустимых строк
- 6 + 7 + 10 * 4
- 5*5*5

### Тестовые примеры:
![image](https://github.com/user-attachments/assets/82303df0-c072-4736-bc18-35cb01f2fe84)
![image](https://github.com/user-attachments/assets/1f13c4a9-f3b5-4adb-903c-4e76ebace92d)
![image](https://github.com/user-attachments/assets/ec8cd089-c470-475b-a97f-b414526d9967)



# Лабораторная работа №6. Реализация алгоритма поиска подстрок с помощью регулярных выражений.
## Цель работы: Реализовать алгоритм поиска в тексте подстрок, соответствующих заданным регулярным выражениям.
## Задачи:
### 13) Построить РВ для того, чтобы найти все годы между 2011 и 2018.
{"Год", QRegularExpression(R"(201[1-8])")},
### 2) Построить РВ, описывающее имя пользователя (набор букв и цифр длиной от 2 до 15 символов, первым символом должен быть @).

{"Имя", QRegularExpression(R"(@[A-Za-z0-9]{2,15})")},
### 20) Построить РВ, описывающее широту (учесть диапазонкорректных значений)
{"Широта", QRegularExpression(R"(-?(90(\.0+)?|([1-8][0-9]|[0-9])(\.\d+)?))")}

### Тестовые примеры:
![image](https://github.com/user-attachments/assets/ccf6c7ab-89c2-4692-a94e-f2c65f0c9cdc)
![image](https://github.com/user-attachments/assets/866f0376-e1ab-4638-ac58-3ceb8547565f)
![image](https://github.com/user-attachments/assets/d5b41f7d-eba1-4ca1-ad40-cbfb77eaf6ef)


# Лабораторная работа №7. Преобразование и анализ кода с использованием Clang и LLVM.
## Цель работы: Познакомиться с инструментами Clang и LLVM, научиться собирать AST и IR-промежуточное представление кода на C/C++, а также извлекать базовую информацию о программе.
## Задачи:
### 1. Установить Clang и LLVM

![Снимок экрана от 2025-05-16 00-46-31](https://github.com/user-attachments/assets/df64577c-4f44-41a9-a2bb-371ef24c9698)

### 2. Скомпилировать простой C-файл с использованием clang и получить его: абстрактное синтаксическое дерево (AST), промежуточное представление LLVM IR;

#### Содержимое main.c

![Снимок экрана от 2025-05-16 00-57-25](https://github.com/user-attachments/assets/a1fc6865-0fad-40b6-afeb-4d1c71629314)

#### Команда clang -Xclang -ast-dump -fsyntax-only main.c (AST)

![Снимок экрана от 2025-05-16 01-18-53](https://github.com/user-attachments/assets/851b86ff-6af2-419f-8621-c8a9a3a3bc42)

#### Команда clang -S -emit-llvm main.c -o main.ll (LLVM IR)

![Снимок экрана от 2025-05-16 01-20-40](https://github.com/user-attachments/assets/74fcfd09-d08b-4ee2-9f34-f96427e1b11e)

### 3. Использовать opt для применения базовой комплексной оптимизации (например, О2)

clang -O0 -S -emit-llvm main.c -o main_O0.ll

![image](https://github.com/user-attachments/assets/85ed5d8a-7872-426c-b9cf-bc0c2ba8fcd2)

#### Команда clang -O2 -S -emit-llvm main.c -o main_O2.ll

![image](https://github.com/user-attachments/assets/9dfa2137-7e16-4b41-9be9-a01e5f903b75)

#### Команда diff main_O0.ll main_O2.ll

![image](https://github.com/user-attachments/assets/3c09200d-efa1-409e-b357-265364de1c94)

### 4. Построить граф потока управления (CFG) для оптимизированной программы;

#### cfg_main.png
![image](https://github.com/user-attachments/assets/fbe3ccbd-35c8-4b6c-a615-9b5d3a3e62ca)

#### cfg_square.png
![image](https://github.com/user-attachments/assets/fb6d7d23-4dae-4a67-b5f2-e620a89c9a67)

### 5. Проанализировать результат, сделать выводы и ответить на контрольные вопросы

1. Что такое Clang, и какова его роль в процессе компиляции программ?
Clang является фронтендом для языков программирования C, C++, Objective-C, Objective-C++ и OpenCL C, использующимся совместно с фреймворком LLVM. Clang транслирует исходные коды в байт-код LLVM, затем фреймворк производит оптимизации и кодогенерацию.

2. Что представляет собой LLVM и как он используется в современных компиляторах?
LLVM - проект программной инфраструктуры для создания компиляторов и сопутствующих им утилит. Состоит из набора компиляторов из языков высокого уровня (так называемых фронтендов), системы оптимизации, интерпретации и компиляции в машинный код.

3. Чем отличается абстрактное синтаксическое дерево (AST) от промежуточного представления LLVM IR?
AST — это иерархическое дерево, отражающее синтаксис исходного кода (структура программных конструкций).

LLVM IR — это линейное, низкоуровневое, машинно-независимое представление, предназначенное для оптимизаций и генерации машинного кода.

4. Для чего необходимо промежуточное представление (IR) в процессе компиляции?
Для того что бы использовать одни и те же оптимизации и бэк разных языков

5. Что делает инструкция alloc в LLVM IR, и зачем она используется в функциях?
alloca выделяет память на стеке для локальных переменных. Это аналог объявления переменной в функции на C.

6. Зачем нужна оптимизация кода в компиляторе, и какие основные цели она преследует?
Оптимизация улучшает производительность и/или уменьшает размер программы.

7. Что такое SSA-форма и почему она важна при оптимизации программ?
SSA - промежуточное представление, используемое компиляторами, в котором каждой переменной значение присваивается лишь единожды. Это упрощает анализ зависимостей между переменными.

8. Что такое граф потока управления (CFG) и как он помогает анализировать поведение программы?
CFG — это граф, где вершины — базовые блоки, а рёбра — переходы управления. Он позволяет анализировать все возможные пути выполнения и применять оптимизации

9. Как устроено представление арифметических операций в LLVM IR (например, умножение, сложение)?
%result = add i32 %a, %b — сложение двух 32-битных чисел.

%result = mul i32 %a, %b — умножение.

10. Почему функции в LLVM IR обычно представляют собой отдельные единицы анализа и оптимизации?
Функции изолированы, их можно анализировать независимо.

11. Что происходит с функцией в LLVM IR, если она вызывается один раз и очень короткая?
Компилятор может применить инлайнинг — заменить вызов функции её телом, чтобы сократить накладные расходы и раскрыть больше возможностей для оптимизации.

12. Какие преимущества даёт использование IR и CFG для автоматических оптимизаций по сравнению с анализом исходного текста на C?
IR проще для анализа, так как уже устранены синтаксические и семантические сложности C.

CFG позволяет точно анализировать потоки исполнения.

Оптимизации становятся более надёжными, платформо-независимыми и масштабируемыми.


### Дополнительное задане:

Задание: Используйте std::map<std::string, int> с инициализацией 2–3
пар. Рассмотрите в AST и IR, как происходит вызов конструктора и вставка
элементов через insert или {}.

![Снимок экрана от 2025-05-19 15-16-11](https://github.com/user-attachments/assets/1bc9978a-f4ef-474b-9876-fc8d44f9d86d)

### AST 
![image](https://github.com/user-attachments/assets/35f7c1ba-4175-4a34-bfc7-2148c70bee46)

В AST виден вызов конструктора std::map, принимающего std::initializer_list<std::pair<const std::string, int>>.
Узел CXXConstructExpr соответствует конструктору с параметром initializer_list.
Каждая пара {"key", value} преобразуется в элемент списка инициализации.

### IR (LLVM)

![image](https://github.com/user-attachments/assets/cf911117-5457-484a-a69c-c4e1880c1def)

Генерируется вызов конструктора std::map с передачей initializer_list.
Компилятор создает временный массив для пар ключ-значение и передает его в конструктор.

### Инициализация через insert

![image](https://github.com/user-attachments/assets/55416204-b3eb-4363-89ae-8e2827ae33e5)

### AST 

![image](https://github.com/user-attachments/assets/9b7dd311-9def-4dab-b136-9724652ad2e1)

Дефолтный конструктор std::map (без параметров)
Три узла CXXMemberCallExpr для вызовов insert
Каждый insert принимает временный объект std::pair

### IR (LLVM)

![image](https://github.com/user-attachments/assets/63de6e0b-18ac-4f26-9597-47199cc93284)

Для каждого insert генерируется отдельный вызов.

### Итог


LLVM/AST отличие

{} → CXXConstructExpr с InitListExpr, вызывается конструктор с initializer_list.

insert() → CXXMemberCallExpr + CallExpr на insert() + создание пары вручную 

Через {}:
В AST используется конструктор с initializer_list.
В IR элементы передаются списком, что может быть эффективнее.

Через insert:
В AST — дефолтный конструктор и отдельные вызовы insert.
В IR — несколько вызовов с накладными расходами.



